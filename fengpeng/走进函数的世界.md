今天在写代码的时候，我犯了一个low的错误，废话不多说，直接上代码：

```
function() {
  console.log('hello world');
}()
```

大家看到之后，第一反应肯定是想：这不是很简单嘛，用()把匿名函数包裹起来就ok了啊，但这是为什么呢？我们一起来探讨下其中的原理吧~~~


### 疑惑解答

为什么上面这种写法会报错呢？

原来，浏览器遇到function关键字的时候会认为这是一个函数声明，函数声明必须包括：关键字function、函数名、形参、函数体。在解析上面代码的时候，解析器发现没有出现函数名而直接出现了()，浏览器便会认为这种定义不符合规范，所以就报错了呗。

既然是缺少函数名，那如果我们给它添加函数名，是不是会正确调用呢？

```
function hello (){
    console.log('hello world');
}()
```

静静等待奇迹出现~~~咦？浏览器在解析的时候怎么又报错了呢？想一想，函数声明是不是有个特权----函数声明提升，也就是说通过函数声明方式声明的函数会被提升到其他代码的前面，提升之后是不是就是这样了：

```
function hello () {
    console.log('hello world');
}
 ...//我们在业务中编写的除了函数之外的其他代码
 
 (); // 咦？这是什么东东？
```

解析器对此也很茫然，不知道该按照什么标准去解析了，只能告诉你写的不够规范了~
大家看一下下面的这种用法，有木有感觉很熟悉呢？

```
var hello = function () {
    console.log('hello world');
}
hello();
```

试想一下，如果用()把上面的函数名hello包裹起来，会发生什么呢?

```
var hello = function () {
    console.log('hello world');
}
(hello)();
```
哈哈，浏览器输出了“hello world”，这种写法是不是特别像数学中的结合律啊~~~

继续对上面的函数调用做一些改变，如果把函数名hello替换成匿名函数,猜想应该也可以调用成功吧？

```
(function() {
  console.log('hello world');
})();
```

呦呵，调用成功了诶~这是为什么呢？因为用()把匿名函数包裹起来，解析器便会认为这是一个函数表达式，函数表达式的后面添加()当然可以正确执行了。此外，除了()之外,也可以使用!等常见的一元运算符来执行匿名函数。

```
!function() {
  console.log('hello world');
}();
```

上面这段代码会输出“hello world”和true。首先执行了匿名函数，输出了"hello wrold"，由于函数的返回值是undefined，然后执行！操作，结果是true。

**PS：**

说到函数定义，需要注意函数声明和函数表达式两者的区别（大神们可以跳过喔~）：前者有个函数声明提升的过程，在代码预解析的时候，会把函数声明提升到代码的顶部，所以在声明函数位置之前调用函数并不会出错；而后者只是进行变量提升，因此，解析器只有执行函数表达式的代码之后才可以调用该函数。


函数总是在特定的作用域中执行的，函数中this的指向是不是也令很多人迷惑呢？一起来探讨其中的奥秘吧~~~

### 走进函数的作用域

**一般情况下，哪个对象调用函数（方法），则this便指向哪个对象。**

通过一些例子来说明该如何确定this的指向

```
var number = 0;
var obj = {
    number: 1,
    getOwnNumber: function() {
        var number = 2;
        return this.number;
    },
    getNumber: function() {
        return function() {
            return this.number;
        };
    }
}
console.log(obj.getOwnNumber());
console.log(obj.getNumber()());
```

大家猜一下，第一个输出结果是多少呢？莫非是2？会不会是1呢？

关键是我们要确定this到底指向哪个对象。回到上面那句话，谁调用函数，函数内的this便会指向哪个对象。很明显，调用getOwnNumber方法的对象是obj对象，而obj对象内部定义的number值为1，所以第一个输出结果是1。

问题来了，第二个输出结果是多少呢？很明显不会是2，那会不会是1呢？那有没有可能是0呢？

还是同样的方法，我们找一找this到底指向哪个对象。obj.getNumber()运行结果是一个匿名函数，然后再执行匿名函数。我们可以把这个过程拆分一下，如下：
```
obj.getNumber() // 返回一个匿名函数
var fun = function () {
    return this.number;    
}
(fun)(); // 等价于fun();
```
经常分解之后，很明显，函数是在全局作用域中调用的，所以此处的this指向window对象，window对象中定义number=0，结果是0应该没用什么问题了吧。


找this的指向是不是比较麻烦呢？别急，ES6语法提供了箭头函数的语法，可以帮助我们解决这个问题。箭头函数是何方神圣，该怎么定义呢？箭头函数的写法如下：

```
   const hello = () => {
        console.log('hello');
    }
```

我们尝试使用箭头函数来改造obj对象的getNumber方法:

```
var number = 0;
var obj= {
    number: 1,
    getOwnNumber() {
        var number = 3;
        return this.number;
    },
    getNumber() {
        return () => {
            return this.number;
        };
    }
}
console.log(obj.getOwnNumber());
console.log(obj.getNumber()());
```

运行之后会发现两个输出结果都是1。这是为什么呢？
来看看阮一峰大神对箭头函数的理解（摘抄自阮大神的ES6标准入门）：
> - 箭头函数体内的this就是**定义时所在的对象**，而不是使用时所在的对象。
>- 箭头函数不可以当做构造函数。也就是说，不可以使用new命令，否则会抛出一个错误。
> - 不可以使用arguments对象，该对象在函数体内不存在。可以使用rest参数代替。
> - 不可以使用yield命令，因此箭头函数不能用作Generator函数

有了箭头函数之后，我们不再需要通过变量保存对象的this指针或者通过bind方法改变this的指针，就能达到我们预期的效果。

但是箭头函数也不是可以在任何场景下都能使用，如果我们要改变this的指向该怎么办？在ES6出现之前，我们可以使用call、apply和bind方法来改变函数中this的指向，ES7提出了使用双冒号（::）的运算符，使得我们可以通过这个运算符来改变箭头函数中this的指向。

除了箭头函数之外，ES6又对之前的函数做了哪些优化呢？

### 函数的其他用法

#### 构造函数

在其他语言中可以通过类实现面向对象的功能，但是在ES6规范公布之前，JavaScript中并没有类的概念，面向对象的语法只能通过构造函数的方式来实现。

```
function Zhuanzhuan (name) {
    this.name = name;
}
Phone.prototype.say = function () {
   console.log('hi~I am zhuanzhuan');
 }
```

要得到对象，必须使用new关键字

```
    var zhuanzhuan = new Zhuanzhuan('zhuanzhuan');
```

 在ES6之前，使用构造函数来创建对象，阅读起来并不是很清晰。ES6提供的class语法跟其他面向对象的语言语法较为接近。
 使用ES6的语法来改写一下上面用构造函数定义的“类”。
 
 ```
class Zhuanzhuan {
    constructor (name) {
        this.name = name;
    }
    say () {
        console.log('hi~I am zhuanzhuan');
    }
}
 let zhuanzhuan = new Zhuanzhuan('zhuanzhuan');
```

看起来是不是特别像C++语言中的面向对象风格呢,出现class之后，妈妈再也不用担心我写的类不够清晰了~~~

JavaScript语言中的函数内容相当丰富，需要我们不断去通过实践去加深理解。骐骥一跃，不能十步，驽马十驾，功在不舍。多总结，多思考，大家如果有好的想法，可以相互交流和分享，每天进步一点点，不断提高自己的专业技能。